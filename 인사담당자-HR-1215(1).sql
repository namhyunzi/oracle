/*
트랜잭션
    데이터베이스의 상태를 변환시키는 하나의 논리적인 기능을 수행하기 위한 논리적인 작업의 단위다.
    예) 홍길동이 이순신에게 100만원을 이체한다.
        1. 홍길동의 계좌에서 잔액을 100만원 감소시킨다 - UPDATE 작업
        2. 이순신의 계좌에서 잔액을 100만원 감소시킨다 - UPDATE 작업
        3. 홍길동의 최근 이체내역에 이순신에게 100만원을 송금한 내용을 추가한다. - INSERT 작업
        
     -  논리적인 작업의 단위(그룹, 묶음, 연산들) = 감소 UPDATE + 증가 UPDATE + 추가 INSERT
     -  논리적인 작업의 단위를 구성하는 모든 SQL 명령이 성공적으로 완료되어야 하나의 작업 단위가
        완료된 것이고, 이 경우에 데이터베이스에 반영시킨다.
        
    트랜잭션 관련 명령어
    COMMIT
        논리적인 작업 단위를 구성하는 모든 작업이 성공적으로 완료되었을 때,
        데이터베이스의 트랜잭션 관리자에게 
        해당 작업 단위내에서 실행했던 처리 결과를 영구적으로 데이터베이스에 반영시키게 한다.
    ROLLBACK
        논리적인 작업 단위를 구성하는 작업 중에서 오류가 발생했을 때,
        데이터베이스의 트랜잭션 관리자에게 
        해당 작업 단위내에서 실행했던 처리 결과의 데이터베이스 반영을 취소시키게 한다.
        
    트랜잭션의 시작과 종료
        트랜잭션의 시작
            - 첫번째 DML 명령문이 실행될 때 새로운 트랜잭션이 시작된다.
            - COMMIT, ROLLBACK 명령을 실행하면 기존 트랜잭션이 종료되고, 새로운 트랜잭션이 시작된다.
        트랜잭션의 종료
            - COMMIT, ROLLBACK 명령을 실행하면 기존 트랜잭션이 종료된다.
            - DBMS에 오류가 발생할 때 AUTO-ROLLBACK이 실행되면서 트랜잭션이 종료된다.
    트랜잭션의 성질
      원자성: A(Atomicity)
        한 트랜잭션내의 연산들은 모두 성공하거나, 전부 실패되는 성질이 있다.
        즉, 부분적인 성공을 허용하지 않는다.
      일관성: C(Consistency)
        트랜잭션이 종료되는 데이터베이스의 데이터는 일관성을 유지해야 한다.
        트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다.
      고립성: I(Isolation)
        모든 트랜잭션은 다른 트랜잭션으로부터 독립적으로 처리된다.
      지속성: D(Durability)
        트랜잭션이 성공적으로 수행되었다면 데이터베이스에 영구적으로 반영된다.
    
    트랜잭션 관련 명령어 실행시 발생하는 일
        COMMIT을 실행하면 일어나는 일
            + 데이터베이스에 데이터를 영구적으로 반영시킨다.
            + 트랜잭션 실행 이전 상태를 완전히 상실한다.(이전 상태로 되돌아갈 수 없다.)
            + 변경된 레코드(데이터 행)의 LOCK이 해제되어, 다른 사용자(트랜잭션)가 변경할 수 있게 된다.
        ROLLBACK을 실행하면 일어나는 일
            + 트랜잭션 실행 이전 상태로 데이터의 상태를 복구시킨다.
            + 변경된 레코드(데이터 행)의 LOCK이 해제되어, 다른 사용자(트랜잭션)가 변경할 수 있게 된다.
        
*/
----------------------------------------------------------------트랜잭션1이 시작됨
UPDATE ACCOUNTS
SET
    DEPOSIT = DEPOSIT - 1000000
WHERE
    NO = 10;                          // 트랜잭션 1의 연산이다.
    
UPDATE ACCOUNTS  
SET 
    DEPOSIT = DEPOSIT + 1000000
WHERE
    NO = 20;                          // 트랜잭션 1의 연산이다.
    
INSERT INTO HISTORIES
VALUES (10,20,1000000, SYSDATE);       // 트랜잭션 1의 연산이다.

COMMIT;                                // 트랜잭션1의 모든 연산이 오류없이 실행되었기 때문에
                                       // 트랜잭션 관리자에게 트랜잭션1의 처리결과를 
                                       // 영구적으로 데이터베이스에 반영시키도록 한다.
----------------------------------------------------------------트랜잭션1이 종료됨
----------------------------------------------------------------트랜잭션2가 실행됨
UPDATE ACCOUNTS
SET
    DEPOSIT = DEPOSIT - 50000
WHERE
    NO = 70;                          // 트랜잭션 2의 연산이다.
    
UPDATE ACCOUNTS
SET
    DEPOSIR = DEPOSIT + 50000
WHERE
    NO = 120;                         // 트랜잭션 2의 연산이다.
    
INSERT INTO HISTORIES
VALUES (70,120,50000, SYSDATE);       // 트랜잭션 2의 연산이다.

ROLLBACK;                             // 트랜잭션2의 INSERT 작업중 오류가 발생하였다.
                                      // 트랜잭션 관리자에게 트랜잭션2의 처리결과를
                                      // 모두 취소시키도록 한다.
----------------------------------------------------------------트랜잭션2가 종료됨
----------------------------------------------------------------트랜잭션3이 실행됨
    